import numpy as np
import re
import math

class Gcode:
    beginning = "G28\nG90\nM83" ## List of beginning commands that must be applied (G28: calibrating axis+going home, G90: setting axis coordinates as absolute, M83: setting extrusion as relative)
    # Customizable values
    axis = ["X", "y", "Z"] ## List of axis
    precision = 1 ## Euclidian distance between each speed value adjustment (the lower, the more precise)
    min_speed = 100 ## Minimum axis speed

    # Values generated by the class' constructor
    current_position = {} ## The object keeps track of the position on each axis
    axis_regex = "" ## Automatically generated Regex to find the axis information on a G0/G1 G-Code command

    def __init__(self):
        """Class' constructor:
         - Makes sure axis names are uppercased
         - Initializes axis' current positions as 0.0
         - Generates the axis finding Regex"""
        self.axis = [axis.upper() for axis in self.axis]
        for axis in self.axis:
            self.current_position[axis] = 0.0
        self.axis_regex = f"[{''.join(self.axis)}]-?\d*\.?\d*"

    @staticmethod
    def acceleration(x):
        """Can be modified by user to adjust acceleration. Has to give a speed according to a given x."""
        return 25*x+20

    def interpret_absolute_movement(self, movement_gcode):
        """From a given G0/G1 G-Code command, returns the desired axis positions as a list of strings (Ex: ['X5.3', 'Y4.0'])"""
        if((movement_gcode[:2] == "G0" ) | (movement_gcode[:2] == "G1")) :
            return(re.findall(self.axis_regex, movement_gcode))

    def update_current_position(self, position):
        """From a list of strings that follow the format returned by the interpret_absolute_movement() method, updates the current position"""
        for axis in position:
            self.current_position[axis[0]] = float(axis[1:])

    def cut_movement(self, movement_gcode, max_speed, total_extrusion_quantity = 0.0):
        """Cuts a G0/G1 G-Code command into multiple sub-commands whose speeds' depend on the value calculated by the acceleration() method. Inputs:
        - movement_gcode : string, ex: 'G1 X84.5 Y94.0'
        - max_speed : float, ex: 2000
        - total_extrusion_quantity : float, ex: 100. By default, 0, which means no extrusion. This is the total E value that will be divided for all sub-commands, relative to the speed of the movement, in a way that the extrusion speed stays constant no matter the variation of moving speeds on the axis."""
        first_position = np.array([self.current_position[axis] for axis in self.axis]) ## Keeps current position in an array
        self.update_current_position(self.interpret_absolute_movement(movement_gcode)) ## Sets the current position as the position that the G-Code targets
        second_position = np.array([self.current_position[axis] for axis in self.axis]) ## Keeps the target position in an array
        direction = second_position - first_position ## Calculates the direction from current to target
        distance = np.linalg.norm(direction) ## Calculates the distance from current to target
        unit_vector = direction / distance ## Calculates the unit vector
        num_steps = int(distance/self.precision) ## Calculates the number of steps, which is the number of sub-commands based on the precision
        points = [first_position + i * unit_vector * self.precision for i in range(1, int(num_steps))]+[second_position] ## Generates the points for each sub-command based on the followed vector and the precision, except for the target position which is kept as-is, in order to avoid any potential differences generated from lack of precision in calculation (ex: avoid target position going from X15 Y20 to X14.89 Y19.8).
        gcode = ""
        x = 0
        speeds = [] ## Array of speeds. Each step's (sub-command) speed will be calculated with the acceleration() method and placed in the array
        tipping_point = math.ceil((len(points)/2)) ## The speed is going to be mirrored so that deceleration = acceleration. To do so, halfway through the points, speed isn't calculated with the acceleration() method anymore and the remaining values of the array will be the array's mirrored first half.
        lines = [] ## Array that contains every sub-command's values before they are compiled into the gcode string at the end of the function
        tipping_count = 0 if len(points) % 2 == 0 else 1; ## Value used to properly reverse the array once the tipping point is reached
        # Each point's position and speed is set in the sub-commands
        for point in points:
            if(x < tipping_point):
                x += 1
                speeds += [self.acceleration(x*self.precision)]
                if speeds[-1] > max_speed:
                    speeds[-1] = max_speed
                elif speeds[-1] < self.min_speed:
                    speeds[-1] = self.min_speed
            else :
                speeds += [speeds[tipping_point-tipping_count-1]]
                tipping_count += 1
            lines += [["G1"]]
            for i in range(len(self.axis)):
                lines[-1] += [(" "+self.axis[i]+str(point[i]))]
            lines[-1] += [f" F{speeds[-1]} \n"]
        # The extrusion value, if there is any, is divided for all sub-commands, relative to the speed of the movement, in a way that the extrusion speed stays constant no matter the variation of moving speeds on the axis.
        if (total_extrusion_quantity > 0):
            ##print(speeds)
            ##print(sum(speeds))
            inverted_speeds = [1/i for i in (speeds)]
            ##print(inverted_speeds)
            sum_inverted_speeds = sum(inverted_speeds)
            ##print(sum_inverted_speeds)
            extrusions = []
            for i in range(len(inverted_speeds)) :
                extrusion = (inverted_speeds[i]/sum_inverted_speeds)*total_extrusion_quantity
                extrusions += [extrusion]
                lines[i].insert(-1, f" E{extrusion}")
            ##print(extrusions)
            ##print(sum(extrusions))
            ##print(lines)
        # In the end, all lines are compiled into a gcode string
        for line in lines:
            gcode += "".join(line)
        return(gcode)

# Object instantiation
gcode = Gcode()
# Performs test prints to check values
print(gcode.acceleration(1))
print(gcode.current_position)
print(gcode.axis)
print(gcode.axis_regex)
# G-Code printing
print(gcode.beginning)
print(gcode.cut_movement("G1 Z20", 2000))
print(gcode.cut_movement("G1 X235 Y40", 2000, 400))